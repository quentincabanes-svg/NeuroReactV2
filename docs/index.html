import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * LFDS Neuro Stimulus App – v2 (from scratch) · Mise à jour
 *
 * Nouveautés demandées:
 * 1) Option "Plein écran au démarrage" : si cochée, la *zone stimuli + bandeau de progression* passe en plein écran au démarrage de la session, avec bouton pour sortir. Compatible rotation.
 * 2) Anti-dépassement mobile/tablette : les stimuli (ex. Stroop) sont *auto-redimensionnés* pour rester entièrement visibles, même avec tailles élevées et position aléatoire.
 *
 * Reste du scope identique: modes, sélections, paramètres, bip, progression, compte à rebours, récup, raccourcis.
 */

// ==================== Constantes ====================
const DEFAULT_COLORS = [
  { name: "ROUGE", hex: "#E53935" },
  { name: "VERT", hex: "#43A047" },
  { name: "BLEU", hex: "#1E88E5" },
  { name: "JAUNE", hex: "#FDD835" },
  { name: "ORANGE", hex: "#FB8C00" },
  { name: "VIOLET", hex: "#8E24AA" },
  { name: "ROSE", hex: "#E91E63" },
  { name: "NOIR", hex: "#111111" },
  { name: "BLANC", hex: "#FFFFFF", outline: true },
  { name: "GRIS", hex: "#9E9E9E" },
  { name: "MARRON", hex: "#6D4C41" },
];

const DEFAULT_NUMBERS = Array.from({ length: 10 }, (_, i) => i);

const ALL_DIRECTIONS = [
  { key: "haut", label: "↑" },
  { key: "bas", label: "↓" },
  { key: "gauche", label: "←" },
  { key: "droite", label: "→" },
  { key: "haut_droite", label: "↗" },
  { key: "bas_droite", label: "↘" },
  { key: "bas_gauche", label: "↙" },
  { key: "haut_gauche", label: "↖" },
];

const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
const randFrom = (arr) => arr[Math.floor(Math.random() * arr.length)];

// ==================== Bip simple ====================
function useBeep() {
  const ctxRef = useRef(null);
  const ensure = () => {
    if (!ctxRef.current) ctxRef.current = new (window.AudioContext || window.webkitAudioContext)();
    return ctxRef.current;
  };
  return {
    async beep(durationMs = 150, frequency = 880, volume = 0.22) {
      try {
        const ctx = ensure();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.value = frequency;
        gain.gain.value = volume;
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        await new Promise((r) => setTimeout(r, durationMs));
        osc.stop();
      } catch {}
    },
  };
}

// ==================== UI Helpers ====================
const Panel = ({ children }) => (
  <div className="rounded-2xl border border-neutral-200 bg-white p-4 shadow-sm">{children}</div>
);
const Section = ({ title, children }) => (
  <div className="mb-6">
    <h3 className="text-sm font-semibold tracking-wider text-neutral-700">{title}</h3>
    <div className="mt-2 rounded-xl border border-neutral-200 bg-white p-3 shadow-sm">{children}</div>
  </div>
);
const Chip = ({ active, onClick, children }) => (
  <button
    onClick={onClick}
    className={`select-none rounded-full border px-3 py-1 text-sm font-medium shadow-sm transition ${
      active ? "border-orange-500 bg-orange-100 text-orange-700" : "border-neutral-200 bg-white text-neutral-700 hover:bg-neutral-50"
    }`}
  >
    {children}
  </button>
);
const ColorSwatch = ({ color, active, onToggle }) => (
  <button
    onClick={onToggle}
    title={color.name}
    className={`relative grid h-10 w-10 place-items-center rounded-md border text-[10px] font-semibold ${
      active ? "ring-2 ring-orange-500 ring-offset-2" : ""
    }`}
    style={{ background: color.hex, color: color.outline ? "#111" : "#fff", borderColor: "#e5e7eb" }}
  >
    {color.outline ? (
      <span className="text-[9px] font-bold text-neutral-700">{color.name}</span>
    ) : (
      <span className="opacity-70">{color.name.substring(0, 2)}</span>
    )}
  </button>
);
const NumberInput = ({ label, value, onChange, min, max, step, unit }) => {
  const [local, setLocal] = useState(String(value));
  useEffect(() => setLocal(String(value)), [value]);
  const commit = () => {
    const n = Number(local);
    if (!Number.isFinite(n)) { setLocal(String(value)); return; }
    const c = clamp(n, min ?? n, max ?? n);
    setLocal(String(c));
    onChange(c);
  };
  return (
    <div>
      <div className="mb-2 flex items-center justify-between gap-2">
        <span className="text-xs font-medium text-neutral-600">{label}</span>
        <div className="rounded-md bg-neutral-50 px-2 py-1 text-xs font-semibold text-neutral-700">{local || value}{unit}</div>
      </div>
      <input
        type="number"
        inputMode="numeric"
        min={min}
        max={max}
        step={step}
        value={local}
        onChange={(e) => setLocal(e.target.value)}
        onBlur={commit}
        onKeyDown={(e) => { if (e.key === "Enter") { e.currentTarget.blur(); } }}
        className="w-full rounded-lg border border-neutral-200 bg-white px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-orange-500"
      />
      {unit ? <div className="mt-1 text-[11px] text-neutral-500">Unité : {unit}{step ? ` • pas ${step}` : ''}</div> : null}
    </div>
  );
};
const Slider = ({ label, value, min, max, step, onChange, unit }) => (
  <div>
    <div className="mb-2 flex items-center justify-between">
      <span className="text-xs font-medium text-neutral-600">{label}</span>
      <span className="rounded-md bg-neutral-50 px-2 py-1 text-xs font-semibold text-neutral-700">{value}{unit}</span>
    </div>
    <input
      type="range"
      min={min}
      max={max}
      step={step}
      value={value}
      onChange={(e) => onChange(Number(e.target.value))}
      className="h-2 w-full cursor-pointer appearance-none rounded-lg bg-neutral-200 accent-orange-500"
    />
  </div>
);

// ==================== Stimulus visuel (anti-dépassement + position sûre) ====================
function Stimulus({ content, bgColor, sizeVH, randomPos }) {
  const containerRef = useRef(null);
  const nodeRef = useRef(null);
  const [containerSize, setContainerSize] = useState({ w: 0, h: 0 });
  const [fontPx, setFontPx] = useState(0);
  const [scale, setScale] = useState(1);
  const [pos, setPos] = useState({ top: "50%", left: "50%" });
  const MARGIN = 24; // marge de sécurité

  // Observe la taille du conteneur (rotation, plein écran, split, etc.)
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;
    const ro = new ResizeObserver((entries) => {
      const r = entries[0].contentRect;
      setContainerSize({ w: r.width, h: r.height });
    });
    ro.observe(el);
    return () => ro.disconnect();
  }, []);

  // Calcule la taille de police de base en px à partir de la hauteur du conteneur
  useEffect(() => {
    if (!containerSize.h) return;
    setFontPx((sizeVH / 100) * containerSize.h);
  }, [containerSize.h, sizeVH]);

  // Mesure le contenu et ajuste l'échelle + la position pour éviter tout dépassement
  useEffect(() => {
    if (!nodeRef.current || !containerSize.w || !containerSize.h) return;
    // Laisser React peindre, puis mesurer
    const raf = requestAnimationFrame(() => {
      const node = nodeRef.current;
      const contW = containerSize.w;
      const contH = containerSize.h;

      // Mesure à l'échelle 1 au centre
      node.style.transform = "translate(-50%, -50%) scale(1)";
      node.style.top = "50%";
      node.style.left = "50%";
      const box = node.getBoundingClientRect();

      const availW = Math.max(1, contW - MARGIN * 2);
      const availH = Math.max(1, contH - MARGIN * 2);
      let sc = Math.min(availW / box.width, availH / box.height);
      if (!Number.isFinite(sc) || sc <= 0) sc = 1;
      sc = Math.min(sc, 1); // ne jamais agrandir au-delà de 1

      // Position sûre si aléatoire
      if (randomPos) {
        const w = box.width * sc;
        const h = box.height * sc;
        const minX = MARGIN + w / 2;
        const maxX = contW - (MARGIN + w / 2);
        const minY = MARGIN + h / 2;
        const maxY = contH - (MARGIN + h / 2);
        const left = maxX >= minX ? Math.random() * (maxX - minX) + minX : contW / 2;
        const top = maxY >= minY ? Math.random() * (maxY - minY) + minY : contH / 2;
        setPos({ top: `${top}px`, left: `${left}px` });
      } else {
        setPos({ top: "50%", left: "50%" });
      }
      setScale(sc);
    });
    return () => cancelAnimationFrame(raf);
  }, [content, fontPx, randomPos, containerSize.w, containerSize.h]);

  return (
    <div ref={containerRef} className="relative flex h-full w-full items-center justify-center overflow-hidden">
      {bgColor ? <div className="absolute inset-0" style={{ background: bgColor, opacity: 0.9 }} /> : null}
      {content ? (
        <div
          ref={nodeRef}
          className="absolute select-none text-center font-extrabold tracking-tight will-change-transform"
          style={{ fontSize: fontPx ? `${fontPx}px` : undefined, top: pos.top, left: pos.left, transform: `translate(-50%, -50%) scale(${scale})` }}
        >
          {content}
        </div>
      ) : null}
    </div>
  );
}

// ==================== App ====================
export default function App() {
  // thème clair
  useEffect(() => { document.documentElement.classList.remove("dark"); }, []);

  // ------- États -------
  const [mode, setMode] = useState("stroop");
  const [repType, setRepType] = useState("apparitions"); // apparitions | duree

  const [selectedColors, setSelectedColors] = useState(DEFAULT_COLORS.map((c) => c.name));
  const [selectedBgColors, setSelectedBgColors] = useState(DEFAULT_COLORS.map((c) => c.name));
  const [selectedNumbers, setSelectedNumbers] = useState(DEFAULT_NUMBERS);
  const [selectedDirections, setSelectedDirections] = useState(ALL_DIRECTIONS.map((d) => d.key));

  const [appearanceMs, setAppearanceMs] = useState(500);
  const [intervalMs, setIntervalMs] = useState(500);
  const [sets, setSets] = useState(3);
  const [reps, setReps] = useState(20);
  const [setDurationSec, setSetDurationSec] = useState(30);
  const [restSec, setRestSec] = useState(30);
  const [sizeVH, setSizeVH] = useState(24);
  const [randomPos, setRandomPos] = useState(false);
  const [beepEnabled, setBeepEnabled] = useState(false);
  const [autoFullscreen, setAutoFullscreen] = useState(false);

  const [multiPool, setMultiPool] = useState({
    stroop: true,
    chiffres: true,
    couleur: true,
    directions: true,
    chiffreCouleur: true,
    directionCouleur: true,
  });

  const [phase, setPhase] = useState("idle"); // idle | countdown | running | rest | finished
  const [currentSet, setCurrentSet] = useState(0);
  const [currentRep, setCurrentRep] = useState(0);
  const [visible, setVisible] = useState(false);
  const [stimulusNode, setStimulusNode] = useState(null);
  const [stimulusBg, setStimulusBg] = useState(null);
  const [countdown, setCountdown] = useState(3);
  const [restCountdown, setRestCountdown] = useState(0);
  const [runningSetElapsedMs, setRunningSetElapsedMs] = useState(0);

  const { beep } = useBeep();
  const rafRef = useRef(null);
  const cancelRef = useRef({ cancelled: false });

  // plein écran ciblé sur la zone stage+progress
  const stageShellRef = useRef(null);
  const [isFullscreen, setIsFullscreen] = useState(false);
  useEffect(() => {
    const onFs = () => setIsFullscreen(!!document.fullscreenElement);
    document.addEventListener("fullscreenchange", onFs);
    return () => document.removeEventListener("fullscreenchange", onFs);
  }, []);
  const enterFullscreen = async () => { try { await stageShellRef.current?.requestFullscreen?.({ navigationUI: "hide" }); } catch {} };
  const exitFullscreen = async () => { try { if (document.fullscreenElement) await document.exitFullscreen(); } catch {} };
  const toggleFullscreen = () => (document.fullscreenElement ? exitFullscreen() : enterFullscreen());

  // ------- Sélections actives -------
  const colorEntries = useMemo(() => DEFAULT_COLORS.filter((c) => selectedColors.includes(c.name)), [selectedColors]);
  const bgEntries = useMemo(() => DEFAULT_COLORS.filter((c) => selectedBgColors.includes(c.name)), [selectedBgColors]);
  const dirEntries = useMemo(() => ALL_DIRECTIONS.filter((d) => selectedDirections.includes(d.key)), [selectedDirections]);
  const numberValues = useMemo(() => [...selectedNumbers].sort((a,b)=>a-b), [selectedNumbers]);

  // ------- Génération d'un stimulus selon le mode -------
  const makeStimulus = (pickMode = mode) => {
    const pickColor = () => randFrom(colorEntries);
    const pickBg = () => randFrom(bgEntries);
    const pickNum = () => randFrom(numberValues);
    const pickDir = () => randFrom(dirEntries);

    if (!colorEntries.length || (!bgEntries.length && (pickMode === 'chiffreCouleur' || pickMode === 'directionCouleur'))) return { node: null, bg: null };

    if (pickMode === "stroop") {
      const word = pickColor();
      const ink = pickColor();
      return { node: <span style={{ color: ink.hex }}>{word.name}</span>, bg: null };
    }
    if (pickMode === "chiffres") {
      const n = pickNum();
      const ink = pickColor();
      return { node: <span style={{ color: ink.hex }}>{n}</span>, bg: null };
    }
    if (pickMode === "couleur") {
      const c = pickColor();
      return { node: null, bg: c.hex };
    }
    if (pickMode === "directions") {
      const d = pickDir();
      return { node: <span style={{ color: "#111" }}>{d.label}</span>, bg: null };
    }
    if (pickMode === "chiffreCouleur") {
      const n = pickNum();
      const ink = pickColor();
      const bg = pickBg();
      return { node: <span style={{ color: ink.hex }}>{n}</span>, bg: bg.hex };
    }
    if (pickMode === "directionCouleur") {
      const d = pickDir();
      const ink = pickColor();
      const bg = pickBg();
      return { node: <span style={{ color: ink.hex }}>{d.label}</span>, bg: bg.hex };
    }
    // multi
    const allowed = Object.keys(multiPool).filter((k) => multiPool[k]);
    const m = allowed.length ? randFrom(allowed) : randFrom(["stroop", "chiffres", "couleur", "directions", "chiffreCouleur", "directionCouleur"]);
    return makeStimulus(m);
  };

  // ------- Orchestration -------
  const stopSession = () => {
    cancelRef.current.cancelled = true;
    setPhase("idle");
    setCurrentSet(0);
    setCurrentRep(0);
    setVisible(false);
    setRunningSetElapsedMs(0);
    if (rafRef.current) cancelAnimationFrame(rafRef.current);
  };

  const runSet = async (index) => {
    setCurrentSet(index + 1);
    setCurrentRep(0);
    setRunningSetElapsedMs(0);
    const start = performance.now();

    const tick = () => {
      setRunningSetElapsedMs(performance.now() - start);
      if (!cancelRef.current.cancelled && phase === "running") rafRef.current = requestAnimationFrame(tick);
    };
    if (rafRef.current) cancelAnimationFrame(rafRef.current);
    rafRef.current = requestAnimationFrame(tick);

    if (repType === "apparitions") {
      for (let i = 0; i < reps; i++) {
        if (cancelRef.current.cancelled) return;
        setCurrentRep(i + 1);
        const st = makeStimulus();
        setStimulusNode(st.node);
        setStimulusBg(st.bg || null);
        setVisible(true);
        if (beepEnabled) beep();
        await new Promise((r) => setTimeout(r, appearanceMs));
        setVisible(false);
        await new Promise((r) => setTimeout(r, intervalMs));
      }
    } else {
      const hard = setDurationSec * 1000;
      let count = 0;
      while (!cancelRef.current.cancelled && performance.now() - start < hard) {
        setCurrentRep(++count);
        const st = makeStimulus();
        setStimulusNode(st.node);
        setStimulusBg(st.bg || null);
        setVisible(true);
        if (beepEnabled) beep();
        await new Promise((r) => setTimeout(r, appearanceMs));
        setVisible(false);
        const remaining = hard - (performance.now() - start);
        if (remaining <= 0) break;
        await new Promise((r) => setTimeout(r, Math.min(intervalMs, remaining)));
      }
    }
  };

  const startSession = async () => {
    cancelRef.current.cancelled = false;

    // Si "plein écran au démarrage" est activé, on tente immédiatement (geste utilisateur)
    if (autoFullscreen && !document.fullscreenElement) {
      await enterFullscreen();
    }

    setPhase("countdown");
    setCountdown(3);
    for (let c = 3; c > 0; c--) {
      if (cancelRef.current.cancelled) return stopSession();
      setCountdown(c);
      await new Promise((r) => setTimeout(r, 1000));
    }

    for (let s = 0; s < sets; s++) {
      if (cancelRef.current.cancelled) return stopSession();
      setPhase("running");
      await runSet(s);
      if (s < sets - 1) {
        setPhase("rest");
        setRestCountdown(restSec);
        for (let t = restSec; t > 0; t--) {
          if (cancelRef.current.cancelled) return stopSession();
          setRestCountdown(t);
          await new Promise((r) => setTimeout(r, 1000));
        }
        if (beepEnabled) beep(250, 660, 0.25);
      }
    }
    setPhase("finished");
  };

  // Raccourcis
  useEffect(() => {
    const onKey = (e) => {
      if (e.code === "Space") { e.preventDefault(); (phase === "idle" || phase === "finished") ? startSession() : stopSession(); }
      if (e.key && e.key.toLowerCase() === "f") { toggleFullscreen(); }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [phase, sets, reps, appearanceMs, intervalMs, repType, setDurationSec, restSec, autoFullscreen]);

  // Progress
  const setProgress = currentSet / Math.max(1, sets);
  const repProgress = repType === "apparitions" ? (reps ? currentRep / reps : 0) : clamp(runningSetElapsedMs / Math.max(1, setDurationSec * 1000), 0, 1);

  // ==================== UI ====================
  return (
    <div className="flex min-h-[100dvh] w-screen flex-col bg-neutral-50 text-neutral-900">{/* 100dvh pour mobiles */}
      {/* Header */}
      <header className="sticky top-0 z-10 border-b border-neutral-200 bg-white/80 backdrop-blur">
        <div className="mx-auto flex max-w-7xl items-center justify-between gap-4 px-4 py-2">
          <div className="flex items-center gap-3">
            <div className="grid h-10 w-10 place-items-center overflow-hidden rounded-lg border border-neutral-200 bg-white">
              <span className="text-xs font-bold text-neutral-500">LFDS</span>
            </div>
            <div>
              <div className="text-sm font-bold tracking-wide">LA FORGE DES SOMMETS</div>
              <div className="text-xs text-neutral-500">Neurocognition · Réactivité</div>
            </div>
          </div>
          <button onClick={toggleFullscreen} className="rounded-lg bg-orange-600 px-3 py-1.5 text-xs font-semibold text-white shadow-sm hover:bg-orange-700">
            {isFullscreen ? "Quitter plein écran" : "Plein écran (F)"}
          </button>
        </div>
      </header>

      {/* Main layout */}
      <div className="mx-auto grid w-full max-w-7xl flex-1 grid-cols-1 gap-4 p-4 md:grid-cols-[360px,1fr]">
        {/* Controls */}
        <aside className="space-y-4">
          <Panel>
            <div className="mb-3 flex items-center justify-between">
              <div className="text-sm font-semibold">Mode</div>
              <div className="text-[11px] font-medium text-neutral-500">Espace = Start/Stop</div>
            </div>
            <div className="flex flex-wrap gap-2">
              {[
                ["stroop", "Stroop"],
                ["chiffres", "Chiffres"],
                ["couleur", "Couleur"],
                ["directions", "Directions"],
                ["chiffreCouleur", "Chiffre + Couleur"],
                ["directionCouleur", "Direction + Couleur"],
                ["multi", "Multi"],
              ].map(([k, label]) => (
                <Chip key={k} active={mode === k} onClick={() => setMode(k)}>{label}</Chip>
              ))}
            </div>
          </Panel>

          <Panel>
            <div className="mb-3 text-sm font-semibold">Sélections</div>
            {/* Couleurs */}
            {["stroop", "chiffres", "couleur", "chiffreCouleur", "directionCouleur", "multi"].includes(mode) && (
              <Section title="Couleurs (texte/éléments)">
                <div className="flex flex-wrap gap-2">
                  {DEFAULT_COLORS.map((c) => (
                    <ColorSwatch key={c.name} color={c} active={selectedColors.includes(c.name)} onToggle={() => setSelectedColors((prev) => prev.includes(c.name) ? prev.filter((x) => x !== c.name) : [...prev, c.name])} />
                  ))}
                </div>
              </Section>
            )}
            {/* Chiffres */}
            {["chiffres", "chiffreCouleur", "multi"].includes(mode) && (
              <Section title="Chiffres">
                <div className="flex flex-wrap gap-2">
                  {DEFAULT_NUMBERS.map((n) => (
                    <Chip key={n} active={selectedNumbers.includes(n)} onClick={() => setSelectedNumbers((p) => p.includes(n) ? p.filter((x)=>x!==n) : [...p, n])}>{n}</Chip>
                  ))}
                </div>
              </Section>
            )}
            {/* Directions */}
            {["directions", "directionCouleur", "multi"].includes(mode) && (
              <Section title="Directions">
                <div className="flex flex-wrap gap-2">
                  {ALL_DIRECTIONS.map((d) => (
                    <Chip key={d.key} active={selectedDirections.includes(d.key)} onClick={() => setSelectedDirections((p) => p.includes(d.key) ? p.filter((x)=>x!==d.key) : [...p, d.key])}>{d.label}</Chip>
                  ))}
                </div>
              </Section>
            )}
            {/* Fonds */}
            {["chiffreCouleur", "directionCouleur", "multi"].includes(mode) && (
              <Section title="Couleurs de fond">
                <div className="flex flex-wrap gap-2">
                  {DEFAULT_COLORS.map((c) => (
                    <ColorSwatch key={c.name+"bg"} color={c} active={selectedBgColors.includes(c.name)} onToggle={() => setSelectedBgColors((prev) => prev.includes(c.name) ? prev.filter((x) => x !== c.name) : [...prev, c.name])} />
                  ))}
                </div>
              </Section>
            )}
            {/* Multi */}
            {mode === "multi" && (
              <Section title="Types inclus dans le tirage aléatoire">
                <div className="flex flex-wrap gap-2">
                  {Object.entries({
                    stroop: "Stroop",
                    chiffres: "Chiffres",
                    couleur: "Couleur",
                    directions: "Directions",
                    chiffreCouleur: "Chiffre + Couleur",
                    directionCouleur: "Direction + Couleur",
                  }).map(([k, label]) => (
                    <Chip key={k} active={!!multiPool[k]} onClick={() => setMultiPool((p) => ({ ...p, [k]: !p[k] }))}>{label}</Chip>
                  ))}
                </div>
              </Section>
            )}
          </Panel>

          <Panel>
            <div className="mb-3 text-sm font-semibold">Paramètres</div>
            <div className="grid gap-4">
              <NumberInput label="Durée d’apparition" value={appearanceMs} onChange={setAppearanceMs} min={50} max={5000} step={50} unit="ms" />
              <NumberInput label="Intervalle entre apparitions" value={intervalMs} onChange={setIntervalMs} min={0} max={5000} step={50} unit="ms" />

              <div className="grid grid-cols-2 gap-3">
                <div>
                  <div className="mb-2 text-xs font-medium text-neutral-600">Type de répétition</div>
                  <div className="flex gap-2">
                    <Chip active={repType === "apparitions"} onClick={() => setRepType("apparitions")}>Apparitions</Chip>
                    <Chip active={repType === "duree"} onClick={() => setRepType("duree")}>Durée</Chip>
                  </div>
                </div>
                <div>
                  <Slider label="Taille du stimulus" value={sizeVH} min={8} max={40} step={1} onChange={setSizeVH} unit="vh" />
                </div>
              </div>

              <div className="grid grid-cols-2 gap-3">
                <NumberInput label="Sets" value={sets} onChange={setSets} min={1} max={999} step={1} />
                {repType === "apparitions" ? (
                  <NumberInput label="Répétitions / set" value={reps} onChange={setReps} min={1} max={999} step={1} />
                ) : (
                  <NumberInput label="Durée par set" value={setDurationSec} onChange={setSetDurationSec} min={1} max={3600} step={1} unit="s" />
                )}
              </div>

              <NumberInput label="Récupération entre sets" value={restSec} onChange={setRestSec} min={1} max={3600} step={1} unit="s" />

              <div className="flex flex-col gap-2 pt-1">
                <label className="flex cursor-pointer items-center gap-2 text-sm">
                  <input type="checkbox" className="h-4 w-4 accent-orange-600" checked={randomPos} onChange={(e) => setRandomPos(e.target.checked)} />
                  Emplacement aléatoire (marges de sécurité)
                </label>
                <label className="flex cursor-pointer items-center gap-2 text-sm">
                  <input type="checkbox" className="h-4 w-4 accent-orange-600" checked={beepEnabled} onChange={(e) => setBeepEnabled(e.target.checked)} />
                  Bip au début de chaque apparition
                </label>
                <label className="flex cursor-pointer items-center gap-2 text-sm">
                  <input type="checkbox" className="h-4 w-4 accent-orange-600" checked={autoFullscreen} onChange={(e) => setAutoFullscreen(e.target.checked)} />
                  Plein écran au démarrage (zone stimuli)
                </label>
              </div>

              <div className="flex items-center gap-2 pt-2">
                {(phase === "idle" || phase === "finished") && (
                  <button onClick={startSession} className="flex-1 rounded-xl bg-orange-600 px-4 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-orange-700">Démarrer</button>
                )}
                {(phase === "countdown" || phase === "running" || phase === "rest") && (
                  <button onClick={stopSession} className="flex-1 rounded-xl border border-orange-200 bg-white px-4 py-2.5 text-sm font-semibold text-orange-700 hover:bg-orange-50">Stop</button>
                )}
              </div>
            </div>
          </Panel>
        </aside>

        {/* Stimulus stage + progression (élément cible du plein écran) */}
        <main ref={stageShellRef} className="relative rounded-2xl border border-neutral-200 bg-white p-4 shadow-sm">
          {/* bouton quitter plein écran visible uniquement en mode FS (mobile) */}
          {isFullscreen && (
            <button onClick={exitFullscreen} className="absolute right-3 top-3 z-30 rounded-md bg-neutral-900/70 px-3 py-1.5 text-xs font-semibold text-white">
              Quitter plein écran
            </button>
          )}

          {/* bandeau progression */}
          <div className="z-10 mb-3 grid grid-cols-1 gap-3 md:grid-cols-2">
            <div className="rounded-lg bg-neutral-100 p-3">
              <div className="mb-1 flex items-center justify-between text-xs font-semibold text-neutral-600">
                <span>Set</span>
                <span>{currentSet}/{sets}</span>
              </div>
              <div className="h-2 w-full overflow-hidden rounded bg-white"><div className="h-full bg-orange-500" style={{ width: `${Math.round(setProgress * 100)}%` }} /></div>
            </div>
            <div className="rounded-lg bg-neutral-100 p-3">
              <div className="mb-1 flex items-center justify-between text-xs font-semibold text-neutral-600">
                <span>{repType === 'apparitions' ? 'Répétitions' : 'Durée du set'}</span>
                <span>{repType === 'apparitions' ? `${currentRep}/${reps}` : `${Math.floor(runningSetElapsedMs/1000)}s / ${setDurationSec}s`}</span>
              </div>
              <div className="h-2 w-full overflow-hidden rounded bg-white"><div className="h-full bg-orange-500" style={{ width: `${Math.round(repProgress * 100)}%` }} /></div>
            </div>
          </div>

          <div className="relative flex min-h-[60vh] flex-1 overflow-hidden rounded-xl bg-neutral-100">
            {phase === 'countdown' && (
              <div className="absolute inset-0 z-20 grid place-items-center bg-white/70">
                <div className="text-[20vh] font-black text-neutral-900">{countdown}</div>
              </div>
            )}
            {phase === 'rest' && (
              <div className="absolute inset-0 z-20 grid place-items-center bg-orange-50">
                <div className="text-center">
                  <div className="text-[8vh] font-extrabold text-orange-700">RÉCUP</div>
                  <div className="text-[18vh] font-black leading-none text-orange-600">{restCountdown}</div>
                  <div className="mt-2 text-sm font-medium text-orange-700">secondes</div>
                </div>
              </div>
            )}
            {phase === 'finished' && (
              <div className="absolute inset-0 z-20 grid place-items-center bg-white/80">
                <div className="rounded-2xl border border-neutral-200 bg-white px-10 py-8 text-center shadow-xl">
                  <div className="mb-2 text-2xl font-extrabold text-neutral-900">Session terminée</div>
                  <div className="text-neutral-600">Bravo ! Appuyez sur Démarrer pour relancer.</div>
                </div>
              </div>
            )}

            <div className="relative z-10 flex-1">
              {visible && (
                <Stimulus content={stimulusNode} bgColor={stimulusBg} sizeVH={sizeVH} randomPos={randomPos} />
              )}
            </div>
          </div>
        </main>
      </div>

      <footer className="border-t border-neutral-200 bg-white/60">
        <div className="mx-auto flex max-w-7xl flex-wrap items-center justify-between gap-3 px-4 py-3 text-xs text-neutral-500">
          <div>© {new Date().getFullYear()} La Forge des Sommets — Prototype d’entraînement neurocognitif</div>
          <div className="flex items-center gap-2">
            <span className="hidden md:inline">Thème clair • Orange & Noir</span>
            <span>·</span>
            <span>Espace: Start/Stop</span>
            <span>·</span>
            <span>F: Plein écran</span>
          </div>
        </div>
      </footer>
    </div>
  );
}
